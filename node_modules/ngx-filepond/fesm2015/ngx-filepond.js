import { __decorate } from 'tslib';
import { EventEmitter, ElementRef, NgZone, Input, Output, Component, ViewEncapsulation, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { supported, create } from 'filepond';
export { registerPlugin } from 'filepond';

// We test if filepond is supported on the current client
const isSupported = supported();
// List of attributes for fallback input
const inputAttributes = [
    "id",
    "name",
    "class",
    "multiple",
    "required",
    "disabled",
    "capture",
    "accept",
];
// Methods not made available on the component
const filteredComponentMethods = [
    "setOptions",
    "on",
    "off",
    "onOnce",
    "appendTo",
    "insertAfter",
    "insertBefore",
    "isAttachedTo",
    "replaceElement",
    "restoreElement",
    "destroy",
];
const outputs = [
    "oninit",
    "onwarning",
    "onerror",
    "onactivatefile",
    "onaddfilestart",
    "onaddfileprogress",
    "onaddfile",
    "onprocessfilestart",
    "onprocessfileprogress",
    "onprocessfileabort",
    "onprocessfilerevert",
    "onprocessfile",
    "onprocessfiles",
    "onremovefile",
    "onpreparefile",
    "onupdatefiles",
];
// Component outline
let FilePondComponent = class FilePondComponent {
    constructor(root, zone) {
        this.options = {};
        // same as outputs array
        this.oninit = new EventEmitter();
        this.onwarning = new EventEmitter();
        this.onerror = new EventEmitter();
        this.onactivatefile = new EventEmitter();
        this.onaddfilestart = new EventEmitter();
        this.onaddfileprogress = new EventEmitter();
        this.onaddfile = new EventEmitter();
        this.onprocessfilestart = new EventEmitter();
        this.onprocessfileprogress = new EventEmitter();
        this.onprocessfileabort = new EventEmitter();
        this.onprocessfilerevert = new EventEmitter();
        this.onprocessfile = new EventEmitter();
        this.onprocessfiles = new EventEmitter();
        this.onremovefile = new EventEmitter();
        this.onpreparefile = new EventEmitter();
        this.onupdatefiles = new EventEmitter();
        this.handleEvent = null;
        this.root = root;
        this.zone = zone;
    }
    ngAfterViewInit() {
        const input = this.root.nativeElement.querySelector("input");
        // transfer relevant attributes to input, this so we still have an input with the correct attributes should file pond not load
        const attributes = this.root.nativeElement.attributes;
        inputAttributes.forEach((name) => {
            const value = attributes[name]
                ? attributes[name].value
                : this.options[name];
            if (!value) {
                return;
            }
            input.setAttribute(name, value);
        });
        // no sufficient features supported in this browser
        if (!isSupported) {
            return;
        }
        // map FilePond events to Angular @outputs
        this.handleEvent = (e) => {
            this[`on${e.type.split(":")[1]}`].emit(Object.assign({}, e.detail));
        };
        outputs.forEach((event) => {
            this.root.nativeElement.addEventListener(`FilePond:${event.substr(2)}`, this.handleEvent);
        });
        // will block angular from listening to events inside the pond
        this.zone.runOutsideAngular(() => {
            // create instance
            this.pond = create(input, Object.assign(Object.assign({}, this.options), { 
                // our initial files
                files: this.files }));
        });
        // Copy instance method references to component instance
        Object.keys(this.pond)
            // remove unwanted methods
            .filter((key) => filteredComponentMethods.indexOf(key) === -1)
            // set method references from the component instance to the pond instance
            .forEach((key) => {
            this[key] = this.pond[key];
        });
    }
    ngOnChanges(changes) {
        // no need to handle first change
        if (changes.firstChange) {
            return;
        }
        // no filepond instance available
        if (!this.pond) {
            return;
        }
        // use new options object as base ( or if not available, use current options )
        const options = changes.options
            ? changes.options.currentValue
            : this.options;
        // see if file list has changed
        if (changes.files &&
            JSON.stringify(changes.files.previousValue) !==
                JSON.stringify(changes.files.currentValue)) {
            // file list has changed
            options.files = changes.files.currentValue;
        }
        // set new options
        this.pond.setOptions(options);
    }
    ngOnDestroy() {
        if (!this.pond) {
            return;
        }
        outputs.forEach((event) => {
            this.root.nativeElement.removeEventListener(`FilePond:${event.substr(2)}`, this.handleEvent);
        });
        this.pond.destroy();
    }
};
FilePondComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
__decorate([
    Input()
], FilePondComponent.prototype, "options", void 0);
__decorate([
    Input()
], FilePondComponent.prototype, "files", void 0);
__decorate([
    Output()
], FilePondComponent.prototype, "oninit", void 0);
__decorate([
    Output()
], FilePondComponent.prototype, "onwarning", void 0);
__decorate([
    Output()
], FilePondComponent.prototype, "onerror", void 0);
__decorate([
    Output()
], FilePondComponent.prototype, "onactivatefile", void 0);
__decorate([
    Output()
], FilePondComponent.prototype, "onaddfilestart", void 0);
__decorate([
    Output()
], FilePondComponent.prototype, "onaddfileprogress", void 0);
__decorate([
    Output()
], FilePondComponent.prototype, "onaddfile", void 0);
__decorate([
    Output()
], FilePondComponent.prototype, "onprocessfilestart", void 0);
__decorate([
    Output()
], FilePondComponent.prototype, "onprocessfileprogress", void 0);
__decorate([
    Output()
], FilePondComponent.prototype, "onprocessfileabort", void 0);
__decorate([
    Output()
], FilePondComponent.prototype, "onprocessfilerevert", void 0);
__decorate([
    Output()
], FilePondComponent.prototype, "onprocessfile", void 0);
__decorate([
    Output()
], FilePondComponent.prototype, "onprocessfiles", void 0);
__decorate([
    Output()
], FilePondComponent.prototype, "onremovefile", void 0);
__decorate([
    Output()
], FilePondComponent.prototype, "onpreparefile", void 0);
__decorate([
    Output()
], FilePondComponent.prototype, "onupdatefiles", void 0);
FilePondComponent = __decorate([
    Component({
        selector: "file-pond",
        encapsulation: ViewEncapsulation.None,
        template: "<div class=\"filepond--wrapper\">\n  <input type=\"file\"/>\n</div>",
        styles: [""]
    })
], FilePondComponent);

let FilePondModule = class FilePondModule {
};
FilePondModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [FilePondComponent],
        exports: [
            FilePondComponent
        ]
    })
], FilePondModule);

/**
 * Generated bundle index. Do not edit.
 */

export { FilePondModule, FilePondComponent as Éµa };
//# sourceMappingURL=ngx-filepond.js.map
